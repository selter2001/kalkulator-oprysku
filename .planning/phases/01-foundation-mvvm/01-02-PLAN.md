---
phase: 01-foundation-mvvm
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - SprayCalculator/Services/SprayCalculatorService.swift
  - SprayCalculator/Models.swift
  - SprayCalculator/ViewModels/CalcViewModel.swift
  - SprayCalculator.xcodeproj/project.pbxproj
autonomous: true

must_haves:
  truths:
    - "SprayCalculatorService istnieje jako czysty struct obliczeniowy bez zaleznosci od SwiftUI"
    - "SprayCalculation ma waterPerFullTank i waterForPartialTank computed properties"
    - "CalcViewModel (@Observable) zawiera cala logike obliczen, walidacji, formatowania i historii"
    - "CalcViewModel przyjmuje HistoryManager przez DI i uzywa SprayCalculatorService do obliczen"
  artifacts:
    - path: "SprayCalculator/Services/SprayCalculatorService.swift"
      provides: "Czysty serwis obliczeniowy (struct, bez SwiftUI)"
    - path: "SprayCalculator/Models.swift"
      provides: "waterPerFullTank, waterForPartialTank computed properties"
    - path: "SprayCalculator/ViewModels/CalcViewModel.swift"
      provides: "@Observable ViewModel z logika obliczen, walidacji, historii"
  key_links:
    - from: "CalcViewModel"
      to: "SprayCalculatorService"
      via: "calculator.calculate() call"
      pattern: "calculator\\.calculate"
    - from: "CalcViewModel"
      to: "HistoryManager"
      via: "historyManager.addCalculation()"
      pattern: "historyManager\\.addCalculation"
---

<objective>
Stworzyc warstwe serwisowa (SprayCalculatorService), rozszerzyc model o per-tank composition, i wyodrebnic CalcViewModel z cala logika obliczen.

Purpose: Dostarcza fundament MVVM -- czysty serwis obliczeniowy i ViewModel z logika biznesowa. Widok (Plan 01-03) bedzie mogl bindowac sie do gotowego VM.
Output: SprayCalculatorService struct, rozszerzone Models.swift, CalcViewModel.swift z @Observable.
</objective>

<execution_context>
@/Users/wojciecholszak/.claude/get-shit-done/workflows/execute-plan.md
@/Users/wojciecholszak/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-mvvm/01-RESEARCH.md
@.planning/phases/01-foundation-mvvm/01-01-SUMMARY.md

Kluczowe pliki do przeczytania przed rozpoczeciem:
- SprayCalculator/ContentView.swift (zrodlo logiki do ekstrakcji -- CalculatorViewWithFavorite)
- SprayCalculator/Models.swift (SprayCalculation -- dodac computed properties)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Stworzyc SprayCalculatorService i rozszerzyc model o per-tank composition</name>
  <files>
    SprayCalculator/Services/SprayCalculatorService.swift
    SprayCalculator/Models.swift
    SprayCalculator.xcodeproj/project.pbxproj
  </files>
  <action>
**1. Stworzyc folder Services/ i plik SprayCalculatorService.swift:**

Stworzyc `SprayCalculator/Services/SprayCalculatorService.swift`:

```swift
import Foundation

struct SprayCalculatorService {
    func calculate(
        fieldArea: Double,
        areaUnit: AreaUnit,
        sprayRate: Double,
        chemicalRate: Double,
        tankCapacity: Double
    ) -> SprayCalculation {
        SprayCalculation(
            fieldArea: fieldArea,
            areaUnit: areaUnit,
            sprayRate: sprayRate,
            chemicalRate: chemicalRate,
            tankCapacity: tankCapacity
        )
    }
}
```

Nazwac struct `SprayCalculatorService` (nie `SprayCalculator`) zeby uniknac konfliktu z nazwa modulu/folderu.

**2. Rozszerzyc model SprayCalculation w Models.swift:**

Dodac 2 computed properties do `SprayCalculation`:

```swift
/// Litry wody do wlania do kazdego pelnego zbiornika
var waterPerFullTank: Double {
    tankCapacity - chemicalPerTank
}

/// Litry wody do wlania do ostatniego niepelnego zbiornika
var waterForPartialTank: Double {
    partialTankVolume - chemicalForPartialTank
}
```

Dodac je zaraz po `chemicalForPartialTank`.

**3. Dodac nowy plik do pbxproj:**

Dodac SprayCalculatorService.swift (Services/) do project.pbxproj:
- Nowy PBXFileReference z unikalnym UUID (np. B1000015)
- Nowy PBXBuildFile z unikalnym UUID (np. A1000015)
- Dodac do PBXGroup children (E1000001)
- Dodac do PBXSourcesBuildPhase files (F1000001)

UWAGA: Plik jest w podfolderze Services/ -- ustawic `path = Services/SprayCalculatorService.swift` w PBXFileReference.
Albo: dodac nowy PBXGroup dla Services/ i umiescic w nim plik. Prostsze rozwiazanie: uzyc `path = "Services/SprayCalculatorService.swift"` bezposrednio w PBXFileReference, bez tworzenia osobnej grupy.
  </action>
  <verify>
cat SprayCalculator/Services/SprayCalculatorService.swift  # Plik istnieje
grep "waterPerFullTank" SprayCalculator/Models.swift  # Computed property dodana
grep "waterForPartialTank" SprayCalculator/Models.swift  # Computed property dodana
grep "SprayCalculatorService.swift" SprayCalculator.xcodeproj/project.pbxproj | wc -l  # >= 2 (FileRef + BuildFile)
  </verify>
  <done>SprayCalculatorService struct istnieje w Services/. Model ma waterPerFullTank i waterForPartialTank. Plik zarejestrowany w pbxproj.</done>
</task>

<task type="auto">
  <name>Task 2: Stworzyc CalcViewModel z cala logika obliczen</name>
  <files>
    SprayCalculator/ViewModels/CalcViewModel.swift
    SprayCalculator.xcodeproj/project.pbxproj
  </files>
  <action>
**1. Stworzyc folder ViewModels/ i plik CalcViewModel.swift:**

Wyodrebnic CALA logike z CalculatorViewWithFavorite do nowego `SprayCalculator/ViewModels/CalcViewModel.swift`:

```swift
import Observation
import Foundation
import UIKit  // Dla UINotificationFeedbackGenerator

@Observable
class CalcViewModel {
    // MARK: - Input State (bindowane do TextField)
    var fieldAreaText: String = ""
    var sprayRateText: String = ""
    var chemicalRateText: String = ""
    var tankCapacityText: String = ""
    var selectedAreaUnit: AreaUnit = .hectares

    // MARK: - Output State
    var calculationResult: SprayCalculation?
    var showResults: Bool = false
    var showAnimation: Bool = false
    var shakingFields: Set<String> = []
    var showError: Bool = false
    var errorMessage: String = ""

    // MARK: - Dependencies
    private let calculator = SprayCalculatorService()
    private let historyManager: HistoryManager

    init(historyManager: HistoryManager) {
        self.historyManager = historyManager
    }

    // MARK: - Actions
    func calculate(invalidValueError: String) {
        // Schowaj klawiature
        UIApplication.shared.sendAction(#selector(UIResponder.resignFirstResponder), to: nil, from: nil, for: nil)

        let fields = validateFields()
        guard fields.isValid else {
            shakeInvalidFields(fields.invalidFields)
            return
        }

        guard let area = parseNumber(fieldAreaText),
              let spray = parseNumber(sprayRateText),
              let chemical = parseNumber(chemicalRateText),
              let tank = parseNumber(tankCapacityText) else {
            errorMessage = invalidValueError
            showError = true
            return
        }

        let result = calculator.calculate(
            fieldArea: area,
            areaUnit: selectedAreaUnit,
            sprayRate: spray,
            chemicalRate: chemical,
            tankCapacity: tank
        )

        calculationResult = result
        historyManager.addCalculation(result)

        showResults = false
        showAnimation = true
    }

    func onAnimationComplete() {
        showAnimation = false
        showResults = true
    }

    func clear() {
        fieldAreaText = ""
        sprayRateText = ""
        chemicalRateText = ""
        tankCapacityText = ""
        calculationResult = nil
        showResults = false
    }

    func loadFavorite(_ favorite: FavoriteConfiguration) {
        sprayRateText = formatNumber(favorite.sprayRate)
        chemicalRateText = formatNumber(favorite.chemicalRate)
        tankCapacityText = formatNumber(favorite.tankCapacity)
        selectedAreaUnit = favorite.areaUnit
    }

    // MARK: - Formatting (public, uzywane tez przez widok)
    func formatNumber(_ value: Double) -> String {
        let formatter = NumberFormatter()
        formatter.numberStyle = .decimal
        formatter.maximumFractionDigits = 2
        formatter.minimumFractionDigits = 0
        formatter.decimalSeparator = ","
        formatter.groupingSeparator = " "
        return formatter.string(from: NSNumber(value: value)) ?? "\(value)"
    }

    func tankFillsDescription(_ result: SprayCalculation, fullTanksLabel: String, partialTankLabel: String) -> String {
        if result.fullTanks > 0 && result.hasPartialTank {
            return "\(result.fullTanks) \(fullTanksLabel) + 1 \(partialTankLabel)"
        } else if result.fullTanks > 0 {
            return "\(result.fullTanks) \(fullTanksLabel)"
        } else if result.hasPartialTank {
            return "1 \(partialTankLabel)"
        }
        return "0"
    }

    // MARK: - Private
    private func validateFields() -> (isValid: Bool, invalidFields: [String]) {
        var invalid: [String] = []
        if fieldAreaText.isEmpty { invalid.append("fieldArea") }
        if sprayRateText.isEmpty { invalid.append("sprayRate") }
        if chemicalRateText.isEmpty { invalid.append("chemicalRate") }
        if tankCapacityText.isEmpty { invalid.append("tankCapacity") }
        return (invalid.isEmpty, invalid)
    }

    private func shakeInvalidFields(_ fields: [String]) {
        let generator = UINotificationFeedbackGenerator()
        generator.notificationOccurred(.error)

        shakingFields = Set(fields)
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) { [weak self] in
            self?.shakingFields.removeAll()
        }
    }

    func parseNumber(_ string: String) -> Double? {
        let normalized = string.replacingOccurrences(of: ",", with: ".")
        return Double(normalized)
    }
}
```

**Uwagi:**
- `calculate()` przyjmuje `invalidValueError: String` -- bo ViewModel NIE ma dostepu do LocalizationManager (localization jest w widoku). Alternatywnie mozna wstrzyknac LocalizationManager do VM, ale prostsze jest przekazanie jednego stringa.
- `tankFillsDescription()` przyjmuje labele jako parametry z tego samego powodu.
- `formatNumber()` i `parseNumber()` sa publiczne -- widok ich uzywa do wyswietlania wynikow.
- Haptic feedback (UINotificationFeedbackGenerator) jest w VM bo jest logika walidacji (nie UI).
- `showSaveDialog` i `favoriteName` POZOSTANA jako @State w widoku -- to jest czysto UI-owy stan dialoga.

**2. Dodac CalcViewModel.swift do pbxproj:**

Dodac nowy plik ViewModels/CalcViewModel.swift:
- PBXFileReference z path = "ViewModels/CalcViewModel.swift"
- PBXBuildFile
- Dodac do PBXGroup i PBXSourcesBuildPhase
  </action>
  <verify>
test -f SprayCalculator/ViewModels/CalcViewModel.swift && echo "OK" || echo "BRAK"  # OK
grep "@Observable" SprayCalculator/ViewModels/CalcViewModel.swift  # Znalezione
grep "SprayCalculatorService()" SprayCalculator/ViewModels/CalcViewModel.swift  # Uzywa serwisu
grep "historyManager.addCalculation" SprayCalculator/ViewModels/CalcViewModel.swift  # Zapisuje do historii
grep "CalcViewModel.swift" SprayCalculator.xcodeproj/project.pbxproj | wc -l  # >= 2
  </verify>
  <done>CalcViewModel.swift istnieje z @Observable, zawiera cala logike obliczen, walidacji, formatowania. Uzywa SprayCalculatorService do obliczen i HistoryManager do zapisu. Zarejestrowany w pbxproj.</done>
</task>

</tasks>

<verification>
1. SprayCalculatorService istnieje w Services/ jako czysty struct
2. SprayCalculation ma waterPerFullTank i waterForPartialTank computed properties
3. CalcViewModel istnieje w ViewModels/ z @Observable
4. CalcViewModel uzywa SprayCalculatorService.calculate() i historyManager.addCalculation()
5. Oba pliki zarejestrowane w pbxproj
6. Build: `xcodebuild -project SprayCalculator.xcodeproj -scheme SprayCalculator build` (jesli dostepne)
</verification>

<success_criteria>
- SprayCalculatorService.swift istnieje jako czysty struct (bez SwiftUI)
- SprayCalculation ma 2 nowe computed properties: waterPerFullTank, waterForPartialTank
- CalcViewModel.swift istnieje z @Observable i cala logika obliczen/walidacji/formatowania
- CalcViewModel przyjmuje HistoryManager przez init (DI)
- Oba nowe pliki zarejestrowane w pbxproj
- Projekt buduje sie bez bledow
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-mvvm/01-02-SUMMARY.md`
</output>
