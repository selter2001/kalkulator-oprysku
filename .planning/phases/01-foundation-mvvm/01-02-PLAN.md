---
phase: 01-foundation-mvvm
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - SprayCalculator/ViewModels/CalcViewModel.swift
  - SprayCalculator/Services/SprayCalculator.swift
  - SprayCalculator/Models.swift
  - SprayCalculator/ContentView.swift
autonomous: true

must_haves:
  truths:
    - "Po obliczeniu uzytkownik widzi sklad pelnego zbiornika: ile litrow wody + ile litrow srodka"
    - "Po obliczeniu uzytkownik widzi sklad niepelnego zbiornika: ile litrow wody + ile litrow srodka"
    - "Po obliczeniu uzytkownik widzi sumaryczna ilosc srodka do kupienia na cale pole"
    - "Cala logika obliczen i walidacji jest w CalcViewModel -- widok tylko wyswietla i binduje"
    - "Historia, ulubione, animacja traktora, walidacja z haptic feedback dzialaja jak wczesniej"
  artifacts:
    - path: "SprayCalculator/ViewModels/CalcViewModel.swift"
      provides: "@Observable ViewModel z logika obliczen, walidacji, historii"
    - path: "SprayCalculator/Services/SprayCalculator.swift"
      provides: "Czysty serwis obliczeniowy (struct, bez SwiftUI)"
    - path: "SprayCalculator/Models.swift"
      provides: "waterPerFullTank, waterForPartialTank computed properties"
  key_links:
    - from: "ContentView.swift (CalculatorViewWithFavorite)"
      to: "CalcViewModel"
      via: "@Bindable binding for TextFields"
      pattern: "@Bindable"
    - from: "CalcViewModel"
      to: "SprayCalculator (service)"
      via: "calculator.calculate() call"
      pattern: "calculator\\.calculate"
    - from: "CalcViewModel"
      to: "HistoryManager"
      via: "historyManager.addCalculation()"
      pattern: "historyManager\\.addCalculation"
    - from: "ContentView.swift resultsSection"
      to: "SprayCalculation.waterPerFullTank/waterForPartialTank"
      via: "result.waterPerFullTank in ResultCard"
      pattern: "waterPerFullTank|waterForPartialTank"
---

<objective>
Wyodrebnic CalcViewModel (@Observable) z logika obliczen z CalculatorViewWithFavorite, stworzyc SprayCalculator service, dodac per-tank composition (woda + srodek na zbiornik), i zaktualizowac UI wynikow.

Purpose: To jest glowny plan fazy -- dostarcza CALC-01, CALC-02, CALC-03 (nowe funkcjonalnosci) i UI-04 (MVVM). Uzytkownik po raz pierwszy zobaczy dokladny sklad kazdego zbiornika.
Output: CalcViewModel, SprayCalculator service, rozszerzone wyniki z per-tank composition.
</objective>

<execution_context>
@/Users/wojciecholszak/.claude/get-shit-done/workflows/execute-plan.md
@/Users/wojciecholszak/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-mvvm/01-RESEARCH.md
@.planning/phases/01-foundation-mvvm/01-01-SUMMARY.md

Kluczowe pliki do przeczytania przed rozpoczeciem:
- SprayCalculator/ContentView.swift (zrodlo logiki do ekstrakcji -- CalculatorViewWithFavorite)
- SprayCalculator/Models.swift (SprayCalculation -- dodac computed properties)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Stworzyc SprayCalculator service i rozszerzyc model o per-tank composition</name>
  <files>
    SprayCalculator/Services/SprayCalculator.swift
    SprayCalculator/Models.swift
    SprayCalculator.xcodeproj/project.pbxproj
  </files>
  <action>
**1. Stworzyc folder Services/ i plik SprayCalculator.swift:**

Stworzyc `SprayCalculator/Services/SprayCalculator.swift`:

```swift
import Foundation

struct SprayCalculatorService {
    func calculate(
        fieldArea: Double,
        areaUnit: AreaUnit,
        sprayRate: Double,
        chemicalRate: Double,
        tankCapacity: Double
    ) -> SprayCalculation {
        SprayCalculation(
            fieldArea: fieldArea,
            areaUnit: areaUnit,
            sprayRate: sprayRate,
            chemicalRate: chemicalRate,
            tankCapacity: tankCapacity
        )
    }
}
```

Nazwac struct `SprayCalculatorService` (nie `SprayCalculator`) zeby uniknac konfliktu z nazwa modulu/folderu.

**2. Rozszerzyc model SprayCalculation w Models.swift:**

Dodac 2 computed properties do `SprayCalculation`:

```swift
/// Litry wody do wlania do kazdego pelnego zbiornika
var waterPerFullTank: Double {
    tankCapacity - chemicalPerTank
}

/// Litry wody do wlania do ostatniego niepelnego zbiornika
var waterForPartialTank: Double {
    partialTankVolume - chemicalForPartialTank
}
```

Dodac je zaraz po `chemicalForPartialTank`.

**3. Dodac nowy plik do pbxproj:**

Dodac SprayCalculator.swift (Services/) do project.pbxproj:
- Nowy PBXFileReference z unikalnym UUID (np. B1000015)
- Nowy PBXBuildFile z unikalnym UUID (np. A1000015)
- Dodac do PBXGroup children (E1000001)
- Dodac do PBXSourcesBuildPhase files (F1000001)

UWAGA: Plik jest w podfolderze Services/ -- ustawic `path = Services/SprayCalculator.swift` w PBXFileReference.
Albo: dodac nowy PBXGroup dla Services/ i umiescic w nim plik. Prostsze rozwiazanie: uzyc `path = "Services/SprayCalculator.swift"` bezposrednio w PBXFileReference, bez tworzenia osobnej grupy.
  </action>
  <verify>
cat SprayCalculator/Services/SprayCalculator.swift  # Plik istnieje
grep "waterPerFullTank" SprayCalculator/Models.swift  # Computed property dodana
grep "waterForPartialTank" SprayCalculator/Models.swift  # Computed property dodana
grep "SprayCalculator.swift" SprayCalculator.xcodeproj/project.pbxproj | wc -l  # >= 2 (FileRef + BuildFile)
  </verify>
  <done>SprayCalculatorService struct istnieje w Services/. Model ma waterPerFullTank i waterForPartialTank. Plik zarejestrowany w pbxproj.</done>
</task>

<task type="auto">
  <name>Task 2: Wyodrebnic CalcViewModel i przebudowac CalculatorViewWithFavorite</name>
  <files>
    SprayCalculator/ViewModels/CalcViewModel.swift
    SprayCalculator/ContentView.swift
    SprayCalculator.xcodeproj/project.pbxproj
  </files>
  <action>
**1. Stworzyc folder ViewModels/ i plik CalcViewModel.swift:**

Wyodrebnic CALA logike z CalculatorViewWithFavorite do nowego `SprayCalculator/ViewModels/CalcViewModel.swift`:

```swift
import Observation
import Foundation
import UIKit  // Dla UINotificationFeedbackGenerator

@Observable
class CalcViewModel {
    // MARK: - Input State (bindowane do TextField)
    var fieldAreaText: String = ""
    var sprayRateText: String = ""
    var chemicalRateText: String = ""
    var tankCapacityText: String = ""
    var selectedAreaUnit: AreaUnit = .hectares

    // MARK: - Output State
    var calculationResult: SprayCalculation?
    var showResults: Bool = false
    var showAnimation: Bool = false
    var shakingFields: Set<String> = []
    var showError: Bool = false
    var errorMessage: String = ""

    // MARK: - Dependencies
    private let calculator = SprayCalculatorService()
    private let historyManager: HistoryManager

    init(historyManager: HistoryManager) {
        self.historyManager = historyManager
    }

    // MARK: - Actions
    func calculate(invalidValueError: String) {
        // Schowaj klawiature
        UIApplication.shared.sendAction(#selector(UIResponder.resignFirstResponder), to: nil, from: nil, for: nil)

        let fields = validateFields()
        guard fields.isValid else {
            shakeInvalidFields(fields.invalidFields)
            return
        }

        guard let area = parseNumber(fieldAreaText),
              let spray = parseNumber(sprayRateText),
              let chemical = parseNumber(chemicalRateText),
              let tank = parseNumber(tankCapacityText) else {
            errorMessage = invalidValueError
            showError = true
            return
        }

        let result = calculator.calculate(
            fieldArea: area,
            areaUnit: selectedAreaUnit,
            sprayRate: spray,
            chemicalRate: chemical,
            tankCapacity: tank
        )

        calculationResult = result
        historyManager.addCalculation(result)

        showResults = false
        showAnimation = true
    }

    func onAnimationComplete() {
        showAnimation = false
        showResults = true
    }

    func clear() {
        fieldAreaText = ""
        sprayRateText = ""
        chemicalRateText = ""
        tankCapacityText = ""
        calculationResult = nil
        showResults = false
    }

    func loadFavorite(_ favorite: FavoriteConfiguration) {
        sprayRateText = formatNumber(favorite.sprayRate)
        chemicalRateText = formatNumber(favorite.chemicalRate)
        tankCapacityText = formatNumber(favorite.tankCapacity)
        selectedAreaUnit = favorite.areaUnit
    }

    // MARK: - Formatting (public, uzywane tez przez widok)
    func formatNumber(_ value: Double) -> String {
        let formatter = NumberFormatter()
        formatter.numberStyle = .decimal
        formatter.maximumFractionDigits = 2
        formatter.minimumFractionDigits = 0
        formatter.decimalSeparator = ","
        formatter.groupingSeparator = " "
        return formatter.string(from: NSNumber(value: value)) ?? "\(value)"
    }

    func tankFillsDescription(_ result: SprayCalculation, fullTanksLabel: String, partialTankLabel: String) -> String {
        if result.fullTanks > 0 && result.hasPartialTank {
            return "\(result.fullTanks) \(fullTanksLabel) + 1 \(partialTankLabel)"
        } else if result.fullTanks > 0 {
            return "\(result.fullTanks) \(fullTanksLabel)"
        } else if result.hasPartialTank {
            return "1 \(partialTankLabel)"
        }
        return "0"
    }

    // MARK: - Private
    private func validateFields() -> (isValid: Bool, invalidFields: [String]) {
        var invalid: [String] = []
        if fieldAreaText.isEmpty { invalid.append("fieldArea") }
        if sprayRateText.isEmpty { invalid.append("sprayRate") }
        if chemicalRateText.isEmpty { invalid.append("chemicalRate") }
        if tankCapacityText.isEmpty { invalid.append("tankCapacity") }
        return (invalid.isEmpty, invalid)
    }

    private func shakeInvalidFields(_ fields: [String]) {
        let generator = UINotificationFeedbackGenerator()
        generator.notificationOccurred(.error)

        shakingFields = Set(fields)
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) { [weak self] in
            self?.shakingFields.removeAll()
        }
    }

    func parseNumber(_ string: String) -> Double? {
        let normalized = string.replacingOccurrences(of: ",", with: ".")
        return Double(normalized)
    }
}
```

**Uwagi:**
- `calculate()` przyjmuje `invalidValueError: String` -- bo ViewModel NIE ma dostepu do LocalizationManager (localization jest w widoku). Alternatywnie mozna wstrzyknac LocalizationManager do VM, ale prostsze jest przekazanie jednego stringa.
- `tankFillsDescription()` przyjmuje labele jako parametry z tego samego powodu.
- `formatNumber()` i `parseNumber()` sa publiczne -- widok ich uzywa do wyswietlania wynikow.
- Haptic feedback (UINotificationFeedbackGenerator) jest w VM bo jest logika walidacji (nie UI).
- `showSaveDialog` i `favoriteName` POZOSTAJA jako @State w widoku -- to jest czysto UI-owy stan dialoga.

**2. Przebudowac CalculatorViewWithFavorite w ContentView.swift:**

Usunac CALA logike obliczen z CalculatorViewWithFavorite. Widok staje sie cienki:

- Usunac @State pola: fieldArea, sprayRate, chemicalRate, tankCapacity, selectedAreaUnit, calculationResult, showResults, showAnimation, shakingFields, showError, errorMessage
- Zachowac @State: showSaveDialog, favoriteName (czysto UI)
- Dodac: `@State private var viewModel: CalcViewModel` -- inicjalizowany z HistoryManager
- Dodac: `@Bindable var vm` lokalnie w body dla binding
- Uzyc $vm.fieldAreaText, $vm.sprayRateText itd. w SprayInputField
- Zamienic performCalculation() na vm.calculate(invalidValueError: localization.invalidValueError)
- Zamienic clearFields() na vm.clear()
- Zamienic loadFavorite() na vm.loadFavorite()
- Zamienic formatNumber() na vm.formatNumber()
- Zamienic tankFillsDescription() na vm.tankFillsDescription()

**Problem inicjalizacji @State + @Environment:**
@Environment nie jest dostepne w init(). Rozwiazanie: Stworzyc CalcViewModel w `ContentView` (nie w `CalculatorViewWithFavorite`), przekazac jako parametr. ContentView ma @Environment(HistoryManager.self), tworzy VM z historyManager w .onAppear lub jako computed.

Lepsze podejscie: Stworzyc CalcViewModel w SprayCalculatorApp z @State i wstrzyknac przez .environment():

W `SprayCalculatorApp.swift` dodac:
```swift
@State private var calcViewModel: CalcViewModel?
```

Ale to tworzy dependency problem (CalcViewModel potrzebuje HistoryManager).

**Najczystsze rozwiazanie:** Stworzyc CalcViewModel w ContentView body (nie jako @State, ale jako let w body) -- NIE, to tworzy nowy obiekt na kazdy rebuild.

**FAKTYCZNE rozwiazanie:** Uzyc initializer z @Environment pattern:

W `CalculatorViewWithFavorite`, przyjac CalcViewModel jako parametr:
```swift
struct CalculatorViewWithFavorite: View {
    @Bindable var viewModel: CalcViewModel
    @Environment(LocalizationManager.self) private var localization
    @Environment(FavoritesManager.self) private var favoritesManager
    @Binding var selectedFavorite: FavoriteConfiguration?
    @State private var showSaveDialog = false
    @State private var favoriteName: String = ""
    // ...
}
```

W ContentView, stworzyc CalcViewModel:
```swift
struct ContentView: View {
    @Environment(LocalizationManager.self) private var localization
    @Environment(HistoryManager.self) private var historyManager
    @Environment(FavoritesManager.self) private var favoritesManager
    @State private var selectedTab = 0
    @State private var calculatorViewKey = UUID()
    @State private var selectedFavorite: FavoriteConfiguration?
    @State private var viewModel: CalcViewModel?

    var body: some View {
        // Lazy init viewModel
        let vm = viewModel ?? {
            let newVM = CalcViewModel(historyManager: historyManager)
            // UWAGA: nie mozna ustawiac @State z body synchronicznie na pierwszym renderze
            // Uzyj .onAppear lub .task
            return newVM
        }()

        TabView(selection: $selectedTab) {
            // ...
            CalculatorViewWrapper(viewModel: vm, selectedFavorite: $selectedFavorite)
            // ...
        }
        .onAppear {
            if viewModel == nil {
                viewModel = CalcViewModel(historyManager: historyManager)
            }
        }
    }
}
```

To jest nieco niezgrabne. **Prostsze i bezpieczne rozwiazanie:** wstrzyknac CalcViewModel tez przez environment z App:

W `SprayCalculatorApp.swift`, po stworzeniu historyManager, stworzyc viewModel:
```swift
@State private var historyManager = HistoryManager()
// CalcViewModel potrzebuje historyManager -- stworzony po historyManager
@State private var calcViewModel: CalcViewModel

init() {
    let hm = HistoryManager()
    _historyManager = State(initialValue: hm)
    _calcViewModel = State(initialValue: CalcViewModel(historyManager: hm))
    // Ale to tworzy DWA HistoryManager!
}
```

**NAJLEPSZE rozwiazanie (proste i dzialajace):**
Uzyc lazy initialization pattern z task/onAppear w ContentView. CalcViewModel jest tworzony raz i trzymany w @State.

```swift
struct ContentView: View {
    @Environment(HistoryManager.self) private var historyManager
    // ...
    @State private var viewModel: CalcViewModel?

    var body: some View {
        Group {
            if let viewModel {
                mainContent(viewModel: viewModel)
            } else {
                Color.clear // Placeholder, natychmiast zastapiony
            }
        }
        .task {
            if viewModel == nil {
                viewModel = CalcViewModel(historyManager: historyManager)
            }
        }
    }

    private func mainContent(viewModel: CalcViewModel) -> some View {
        TabView(selection: $selectedTab) { /* ... */ }
    }
}
```

Albo jeszcze prosciej -- skoro HistoryManager jest tworzony raz w App i wstrzykiwany, CalcViewModel moze byc tez tworzony w App:

```swift
// SprayCalculatorApp.swift
@main
struct SprayCalculatorApp: App {
    @State private var localization = LocalizationManager()
    @State private var historyManager = HistoryManager()
    @State private var favoritesManager = FavoritesManager()

    var body: some Scene {
        WindowGroup {
            ContentView()
                .environment(localization)
                .environment(historyManager)
                .environment(favoritesManager)
        }
    }
}
```

CalcViewModel tworzony w ContentView z @State i inicjalizowany w task:
```swift
@State private var viewModel: CalcViewModel?
// W .task: viewModel = CalcViewModel(historyManager: historyManager)
```

**UZYJ TEGO PODEJSCIA.** Implementuj je dokladnie jak opisano wyzej.

Usunac `CalculatorViewWrapper` -- nie jest juz potrzebny. ContentView bezposrednio renderuje `CalculatorViewWithFavorite`.

**3. Rozszerzyc resultsSection o per-tank composition:**

W CalculatorViewWithFavorite.resultsSection() dodac NOWE ResultCard po istniejacych:

```swift
// ISTNIEJACE: Ciecz robocza, Srodek, Napelnienia...

// NOWE: Sklad pelnego zbiornika (CALC-01)
ResultCard(
    icon: "ðŸª£",
    title: localization.fullTankComposition,
    value: "\(viewModel.formatNumber(result.waterPerFullTank)) l + \(viewModel.formatNumber(result.chemicalPerTank)) l",
    unit: "",
    detail: "\(localization.water) + \(localization.chemical)",
    delay: 0.4
)

// NOWE: Sklad niepelnego zbiornika (CALC-02)
if result.hasPartialTank {
    ResultCard(
        icon: "ðŸ«—",
        title: localization.partialTankComposition,
        value: "\(viewModel.formatNumber(result.waterForPartialTank)) l + \(viewModel.formatNumber(result.chemicalForPartialTank)) l",
        unit: "",
        detail: "\(localization.water) + \(localization.chemical)",
        delay: 0.5
    )
}

// NOWE: Srodek do kupienia (CALC-03)
ResultCard(
    icon: "ðŸ›’",
    title: localization.totalChemicalToBuy,
    value: viewModel.formatNumber(result.totalChemical),
    unit: localization.liters,
    delay: 0.6
)
```

**4. Dodac brakujace klucze lokalizacji do LocalizationManager:**

Dodac w `LocalizationManager.swift`:
```swift
var fullTankComposition: String {
    currentLanguage == .polish ? "SkÅ‚ad peÅ‚nego zbiornika" : "Full tank composition"
}

var partialTankComposition: String {
    currentLanguage == .polish ? "SkÅ‚ad niepeÅ‚nego zbiornika" : "Partial tank composition"
}

var water: String {
    currentLanguage == .polish ? "Woda" : "Water"
}

var totalChemicalToBuy: String {
    currentLanguage == .polish ? "Åšrodek do kupienia" : "Chemical to buy"
}
```

**5. Dodac CalcViewModel.swift do pbxproj:**

Dodac nowy plik ViewModels/CalcViewModel.swift:
- PBXFileReference z path = "ViewModels/CalcViewModel.swift"
- PBXBuildFile
- Dodac do PBXGroup i PBXSourcesBuildPhase

**6. Zaktualizowac animacje w CalculatorViewWithFavorite:**

Animacja traktora musi wywolac `viewModel.onAnimationComplete()`:
```swift
.overlay {
    if viewModel.showAnimation {
        TractorSprayingAnimation {
            withAnimation(.spring(response: 0.5, dampingFraction: 0.8)) {
                viewModel.onAnimationComplete()
            }
        }
        .transition(.opacity)
    }
}
```

**7. Zaktualizowac saveFavorite w CalculatorViewWithFavorite:**

```swift
private func saveFavorite() {
    let favorite = FavoriteConfiguration(
        name: favoriteName,
        sprayRate: viewModel.parseNumber(viewModel.sprayRateText) ?? 0,
        chemicalRate: viewModel.parseNumber(viewModel.chemicalRateText) ?? 0,
        tankCapacity: viewModel.parseNumber(viewModel.tankCapacityText) ?? 0,
        areaUnit: viewModel.selectedAreaUnit
    )
    favoritesManager.addFavorite(favorite)
    showSaveDialog = false
    favoriteName = ""
}
```

**8. Zaktualizowac onChange selectedFavorite:**

```swift
.onChange(of: selectedFavorite) {
    if let favorite = selectedFavorite {
        viewModel.loadFavorite(favorite)
        selectedFavorite = nil
    }
}
```
  </action>
  <verify>
test -f SprayCalculator/ViewModels/CalcViewModel.swift && echo "OK" || echo "BRAK"  # OK
grep "@Observable" SprayCalculator/ViewModels/CalcViewModel.swift  # Znalezione
grep "waterPerFullTank" SprayCalculator/Models.swift  # Znalezione
grep "waterForPartialTank" SprayCalculator/Models.swift  # Znalezione
grep "fullTankComposition" SprayCalculator/ContentView.swift  # Znalezione w resultsSection
grep "totalChemicalToBuy" SprayCalculator/ContentView.swift  # Znalezione
grep "performCalculation\|func calculate\b" SprayCalculator/ContentView.swift | wc -l  # 0 (logika przeniesiona do VM)
grep "CalcViewModel" SprayCalculator.xcodeproj/project.pbxproj | wc -l  # >= 2
  </verify>
  <done>CalcViewModel trzyma cala logike obliczen. CalculatorViewWithFavorite jest cienkim widokiem z bindingami. Wyniki pokazuja sklad pelnego zbiornika (woda+srodek), sklad niepelnego zbiornika, i srodek do kupienia. Historia, ulubione i animacja dzialaja.</done>
</task>

</tasks>

<verification>
1. CALC-01: resultsSection wyswietla waterPerFullTank + chemicalPerTank (sklad pelnego zbiornika)
2. CALC-02: resultsSection wyswietla waterForPartialTank + chemicalForPartialTank (sklad niepelnego) -- tylko gdy hasPartialTank
3. CALC-03: resultsSection wyswietla totalChemical jako "Srodek do kupienia"
4. UI-04: Logika obliczen, walidacji, formatowania jest w CalcViewModel -- widok nie ma zadnej logiki biznesowej
5. Istniejace funkcje: historia dodaje obliczenia, animacja traktora dziala, walidacja trzesie pustymi polami, ulubione laduja wartosci
6. Build: `xcodebuild -project SprayCalculator.xcodeproj -scheme SprayCalculator build` (jesli dostepne)
</verification>

<success_criteria>
- CalcViewModel.swift istnieje z @Observable i cala logika obliczen
- SprayCalculatorService.swift istnieje jako czysty serwis (struct)
- SprayCalculation ma waterPerFullTank i waterForPartialTank
- Wyniki pokazuja 3 nowe karty: sklad pelnego zbiornika, sklad niepelnego zbiornika, srodek do kupienia
- ContentView/CalculatorViewWithFavorite nie zawieraja logiki obliczen -- tylko binding do VM
- Projekt buduje sie bez bledow
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-mvvm/01-02-SUMMARY.md`
</output>
